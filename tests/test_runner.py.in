#!/usr/bin/env python2
# -*- coding: utf-8 -*-#
# @(#)test_runner.py.in
#
#
# Copyright (C) 2013, GC3, University of Zurich. All rights reserved.
#
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
"""
This script checks the output files generated by

```
 $ geotop TEST_DIR/geotop.inpts
```
against the (considered) correct result.

Specifically, each test run on a TEST_DIR will pass if and only if:

* TEST_DIR/_SUCCESSFUL_RUN exists and is a file

* for each OUTPUT_TABS and OUTPUT_MAPS in TEST_DIR:
    for each FILE in OUTPUT_TABS:
      - TEST_DIR/COMPARE_TABS/FILE exists and is a file,
      - TEST_DIR/COMPARE_TABS/FILE is equal to TEST_DIR/OUTPUT_TABS/FILE.

Adding a new test should be as easy as:

* adding a directory with input files for geotop;

* adding a directory containing the correct output files generated by geotop.

"""

__author__ = 'Antonio Messina <antonio.s.messina@gmail.com>, Paolo Gorlani'
__docformat__ = 'reStructuredText'

import filecmp
import os
import re

try:
    import pandas
except ImportError:
    pandas = None

if pandas:
    import warnings
    warnings.simplefilter(action = "ignore", category = FutureWarning)

# path to the geotop binary
GEOTOP = "@GEOTOP_PROGRAM_PATH@"
# geotop compile flag
METEOIO_ACTUAL_STATUS = "@METEOIOPREFIX@"

# directory containing this file
TESTDIR = "@GEOTOP_TEST_DIR@"

# output directories
OUTPUT_TABS = "output-tabs" 
OUTPUT_MAPS = "output-maps" 

#  reference output directories
COMPARE_TABS = [ OUTPUT_TABS+"-METEOIO-"+METEOIO_ACTUAL_STATUS.upper() ]
COMPARE_MAPS = [ OUTPUT_MAPS+"-METEOIO-"+METEOIO_ACTUAL_STATUS.upper() ]


def assert_is_file(fname, msg=None):
    assert os.path.isfile(fname), msg or "%s is not a file" % fname


def compare_files_exactly(fpath_ok, fpath_new, delta):
    """
    Compare the *content* of two files. It checks that they are *exactly* the
    same files.
    """

    assert filecmp.cmp(fpath_ok, fpath_new), "File %s and %s differ!" % (fpath_ok, fpath_new)



def compare_tab_files(fpath_ok, fpath_new, deltas):
    """
    Compare the data in two files and check if they are *almost*
    equal, depending on a delta which depends on the field name.
    """
    data_ok = pandas.read_csv(fpath_ok, na_values=['nan', '-nan']).fillna(0)
    data_new = pandas.read_csv(fpath_new, na_values=['nan', '-nan']).fillna(0)
    # get the correct delta value/dictionary

    # check fields one by one
    for field in data_ok:
        if field in deltas:
            assert (abs(data_ok[field] - data_new[field]) <= deltas[field]).all(), \
                   "Field '%s' in file %s is too different: %d rows differ "  \
                   "more than %f from the correct ones (maxdiff=%f)." %   \
                   (field, fpath_new, (abs(data_ok[field] - data_new[field]) > deltas[field]).sum(),  \
                   deltas[field], abs(data_ok[field] - data_new[field]).max())
        else:
            # Check that all the fields are almost equal
            if not((data_ok[field] == data_new[field]).all()):
                assert (abs(data_ok[field] - data_new[field]) <= 0.0002).all(),  \
                   "Field '%s' of files %s and %s differs!" % (field, fpath_ok, fpath_new)

def compare_map_files(fpath_ok, fpath_new, deltas):
    """
    Compare the data in two files and check if they are *almost*
    equal, depending on a delta which depends on the field name.
    """
    data_ok = pandas.read_csv(fpath_ok, sep=' ', skiprows=6, header=None, na_values=['nan', '-nan'])
    data_new = pandas.read_csv(fpath_new, sep=' ', skiprows=6, header=None, na_values=['nan', '-nan'])
    assert data_ok.shape == data_new.shape
    # get the correct delta value/dictionary
    try:
        diff = (data_ok - data_new).apply(abs).fillna(0)
    except (ValueError, TypeError):
        return compare_files_exactly(fpath_ok, fpath_new, None)
    assert (diff <= deltas).all().all(), \
           "File %s: %d fields are bigger than predefined delta: " \
           "%f > %f" % (fpath_new, (diff > deltas).count().sum(), diff.max().max(), deltas)
    

class TestValidRun(object):
    cmp_functions = [
        (r'(.*/)?point_info_[0-9]{4}.txt', compare_files_exactly, None),
        (r'(.*/)?.*[0-9]{4}.txt', compare_tab_files, {
            'H[W/m2]'                         : 0.00001, #for coldelaporte surface
            'highest_water_table_depth[mm]'   : 0.001, #for coldelaporte surface
            'Hg_unveg[W/m2]'                  : 0.00001, #for coldelaporte surface
            'LE[W/m2]'                        : 0.00001, #for coldelaporte surface
            'lowest_water_table_depth[mm]'    : 0.001, #for coldelaporte surface
            'LObukhov[m]'                     : 0.00005, #for calabria point
	    'Wind_direction[deg]'             : 0.00002, #for Calabria: point0001
            'snow_depth[mm]'                  : 3.0,
            'snow_water_equivalent[mm]'       : 1.0,
            'Tair[C]'                         : 0.0,
            'Relative_Humidity[-]'            : 0.0,
            'Tsurface[C]'                     : 3.0,
            'Surface_Energy_balance[W/m2]'   : 20.0,
            'Soil_heat_flux[W/m2]'           : 50.0,
            'SWin[W/m2]'                      : 0.6,
            'SWbeam[W/m2]'                    : 0.0,
            'SWdiff[W/m2]'                    : 0.6,
            'LWnet[W/m2]'                    : 15.0,
            'LWin[W/m2]'                      : 0.0,
            'SWnet[W/m2]'                    : 20.0,
            'SWup[W/m2]'                      : 0.00001, #for coldelaporte surface
            'Run'                             : 0.0,
            '5.000000 '                       : 0.000002, #for costantmeteo wliq
            '24.875930 '                      : 0.000002, #for hillslope02 psiliq
            '25.000000 '                      : 0.000002, #for costantmeteo wliq
            '74.627789 '                      : 0.000002, #for hillslope02 psiliq 
            '90.000000 '                      : 0.000002, #for costantmeteo wliq
            '100.000000'                     : 0.1, ############# <----
            '140.000000 '                     : 0.1,
            '150.000000 '                     : 0.000002, #for bro water_press
            '174.131508 '                     : 0.000002, #for hillslope02 psiliq
            '315.000000 '                     : 0.000002, #for costantmeteo wliq
            '530.000000 '                     : 0.1,
            '890.000000 '                     : 0.000002, #for costantmeteo wliq
            '1780.000000  '                   : 0.1,
            '2040.000000  '                   : 0.000002, #for costantmeteo wliq
            'Pressure[mbar]'                  : 1.0, #added for calabria
            }),
        # (r'(.*/)?SWEN.*.asc', compare_map_files, 1.0),
        (r'(.*/)?SWEDENSITYN.*.asc', compare_map_files, 100.0),
        # (r'(.*/)?MMGSTN.*.asc', compare_map_files, 7.4),
        # ?(r'(.*/)?TLLLLLN.*.asc', compare_map_files, 0.3),
        (r'(.*/)?snowdepthN.*.asc', compare_map_files, 10.0),
        (r'(.*/)?Pw.*.asc', compare_map_files, 10.0), #added for vhape of intel compiler
        (r'(.*/)?.*.asc', compare_map_files, 1.0),
        (r'(.*/)?.*discharge.txt', compare_tab_files, { #added for borden05
		'Qoutlandsub[m3/s]'		: 0.000001, #added for borden05
		'Qoutlandsup[m3/s]'		: 0.002, #added for borden05 and for vhape
            }),
    ]

    def setUp(self):
        os.chdir(TESTDIR)

    def compare_files(self, fpath_ok, fpath_new):
        """
        Call self.compare_files_using_delta() if we do know the format
        of the file, and self.compare_files_exactly if fpath_ok otherwise.
        """
        if not pandas:
            return compare_files_exactly(fpath_ok, fpath_new, None)

        for (regexp, func, delta) in self.cmp_functions:
            if re.match(regexp, fpath_ok):
                return func(fpath_ok, fpath_new, delta)
        return compare_files_exactly(fpath_ok, fpath_new, None)

    def _test_template(self, directory, referencedir, resultdir):
        """
        This template function will run geotop on a specific test
        directory, check if the `_SUCCESSFUL_RUN` is created, and
        check that all the files stored in ``COMPARE_MAPS and COMPARE_TABS dir`` have been
        created by the simulation and compare them.
        """


        # Change the current working directory, because
        # ``geotop.inpts`` files usually have relative paths.
        os.chdir(directory)

	#assert_is_file(GEOTOP)

        # Check that _SUCCESSFUL_RUN file exists)
        assert_is_file(os.path.join(directory, '_SUCCESSFUL_RUN'))


        # and for each file in the RESULT directory...
        for fname in os.listdir(referencedir):
            # fpath_ok is the file in ``reference``
            fpath_ok = os.path.join(referencedir,fname)
            # fpath_new is the corresponding file just produced by geotop
            fpath_new = os.path.join(resultdir, fname)
            # fpath_new has to exists and...
            #if not os.path.isfile(fpath_new): continue ##### FIX 
            assert_is_file(fpath_new)
            # ...it has to be equal to the file in ``results``
            self.compare_files(fpath_ok, fpath_new)

    def test_generator(self):
        actual_dir = os.getcwd()
        if os.path.isdir(actual_dir) and os.path.isfile(os.path.join(actual_dir, 'geotop.inpts')):
            if os.path.isdir(os.path.join(actual_dir, OUTPUT_TABS)):
	        resultdir=os.path.join(actual_dir, OUTPUT_TABS)
                for tabs_dir in COMPARE_TABS:
		    referencedir=os.path.join(actual_dir, tabs_dir)
                    if os.path.isdir(os.path.join(actual_dir, tabs_dir)):
                        self._test_template( actual_dir, referencedir, resultdir )
            if os.path.isdir(os.path.join(actual_dir, OUTPUT_MAPS)):
	        resultdir=os.path.join(actual_dir, OUTPUT_MAPS)
                for maps in COMPARE_MAPS:
		    referencedir=os.path.join(actual_dir, maps)
                    if os.path.isdir(os.path.join(actual_dir, maps)):
                        self._test_template( actual_dir, referencedir, resultdir )

if __name__ == "__main__":
    #import nose
    #nose.run()

    t = TestValidRun()
    t.test_generator()





